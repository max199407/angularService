"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * SonarTS
 * Copyright (C) 2017-2017 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
const Lint = require("tslint");
const ts = require("typescript");
const navigation_1 = require("../utils/navigation");
const sonar_utils_1 = require("../runner/sonar-utils");
class Rule extends Lint.Rules.TypedRule {
    applyWithProgram(sourceFile, program) {
        return this.applyWithWalker(new Walker(sourceFile, this.getOptions(), program));
    }
}
Rule.metadata = {
    description: "Collection elements should not be replaced unconditionally",
    options: null,
    optionsDescription: "",
    rationale: Lint.Utils.dedent `
      It is highly suspicious when a value is saved for a key or index and then unconditionally overwritten. Such overwrites are likely an error.`,
    rspecKey: "RSPEC-4143",
    ruleName: "no-element-overwrite",
    type: "functionality",
    typescriptOnly: false,
};
exports.Rule = Rule;
class Walker extends Lint.ProgramAwareRuleWalker {
    visitSourceFile(node) {
        this.checkStatements(node.statements);
        super.visitSourceFile(node);
    }
    visitBlock(node) {
        this.checkStatements(node.statements);
        super.visitBlock(node);
    }
    visitCaseClause(node) {
        this.checkStatements(node.statements);
        super.visitCaseClause(node);
    }
    checkStatements(statements) {
        const usedKeys = new Map();
        let collection = null;
        statements.forEach(statement => {
            const keyWriteUsage = this.keyWriteUsage(statement);
            if (keyWriteUsage) {
                if (collection && keyWriteUsage.collectionSymbol !== collection) {
                    usedKeys.clear();
                }
                const sameKeyWriteUsage = usedKeys.get(keyWriteUsage.indexOrKey);
                if (sameKeyWriteUsage) {
                    this.addFailureAtNode(keyWriteUsage.node, this.message(keyWriteUsage.indexOrKey, sameKeyWriteUsage.node));
                }
                usedKeys.set(keyWriteUsage.indexOrKey, keyWriteUsage);
                collection = keyWriteUsage.collectionSymbol;
            }
            else {
                usedKeys.clear();
            }
        });
    }
    keyWriteUsage(node) {
        if (navigation_1.is(node, ts.SyntaxKind.ExpressionStatement)) {
            const expression = node.expression;
            return (this.arrayKeyWriteUsage(expression) ||
                this.mapKeyWriteUsage(expression) ||
                this.setKeyWriteUsage(expression) ||
                this.objectKeyWriteUsage(expression));
        }
    }
    arrayKeyWriteUsage(node) {
        if (navigation_1.isAssignment(node) && navigation_1.is(node.left, ts.SyntaxKind.ElementAccessExpression)) {
            const lhs = node.left;
            const array = this.getTypeChecker().getSymbolAtLocation(lhs.expression);
            if (!array || this.usedInRhs(node.right, array))
                return;
            const index = this.extractIndex(lhs.argumentExpression);
            if (!index)
                return;
            return {
                collectionSymbol: array,
                indexOrKey: index,
                node: lhs.expression,
            };
        }
    }
    usedInRhs(rhs, symbol) {
        return navigation_1.descendants(rhs)
            .filter(child => child.kind === ts.SyntaxKind.Identifier)
            .some(id => this.getTypeChecker().getSymbolAtLocation(id) === symbol);
    }
    mapKeyWriteUsage(node) {
        return this.callExpression(node, "Map", "set");
    }
    setKeyWriteUsage(node) {
        return this.callExpression(node, "Set", "add");
    }
    callExpression(node, typeName, method) {
        if (navigation_1.is(node, ts.SyntaxKind.CallExpression)) {
            const callExpression = node;
            if (navigation_1.is(callExpression.expression, ts.SyntaxKind.PropertyAccessExpression)) {
                const propertyAccess = callExpression.expression;
                const type = this.getTypeChecker().getTypeAtLocation(propertyAccess.expression);
                if (type.symbol && type.symbol.name === typeName && propertyAccess.name.text === method) {
                    const lhsSymbol = this.getTypeChecker().getSymbolAtLocation(propertyAccess.expression);
                    const key = this.extractIndex(callExpression.arguments[0]);
                    if (!lhsSymbol || !key)
                        return;
                    return {
                        collectionSymbol: lhsSymbol,
                        indexOrKey: key,
                        node: propertyAccess.expression,
                    };
                }
            }
        }
    }
    objectKeyWriteUsage(node) {
        if (navigation_1.isAssignment(node) && navigation_1.is(node.left, ts.SyntaxKind.PropertyAccessExpression)) {
            const lhs = node.left;
            // avoid deeply nested property access
            if (!navigation_1.is(lhs.expression, ts.SyntaxKind.Identifier))
                return;
            const objectSymbol = this.getTypeChecker().getSymbolAtLocation(lhs.expression);
            if (!objectSymbol)
                return;
            if (this.usedInRhs(node.right, objectSymbol))
                return;
            const property = lhs.name.text;
            if (!property)
                return;
            return {
                collectionSymbol: objectSymbol,
                indexOrKey: property,
                node: lhs.expression,
            };
        }
    }
    extractIndex(node) {
        if (!node)
            return;
        if (navigation_1.is(node, ts.SyntaxKind.NumericLiteral, ts.SyntaxKind.StringLiteral)) {
            const literal = node;
            return literal.text;
        }
        const symbol = this.getTypeChecker().getSymbolAtLocation(node);
        return symbol && symbol.name;
    }
    message(index, previousUsage) {
        const line = sonar_utils_1.nodeToSonarLine(previousUsage);
        return `Verify this is the index that was intended; "${index}" was already set on line ${line}.`;
    }
}
//# sourceMappingURL=noElementOverwriteRule.js.map